import { createContext, ReactNode, useContext, useEffect, useState } from "react";
import {
  useQuery,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { insertUserSchema, User, InsertUser, LoginData } from "@shared/schema";
import { apiRequest, queryClient } from "../lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import { useLocation } from "wouter";

// Helper function to get client IP
async function getClientIP(): Promise<string> {
  try {
    const response = await fetch('https://api.ipify.org?format=json');
    const data = await response.json();
    return data.ip;
  } catch (error) {
    console.warn('‚ö†Ô∏è ŸÅÿ¥ŸÑ ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ IP ÿßŸÑÿπŸÖŸäŸÑ:', error);
    return 'unknown';
  }
}

type AuthContextType = {
  user: Omit<User, "password"> | null;
  isLoading: boolean;
  error: Error | null;
  loginMutation: UseMutationResult<{token?: string, user?: Omit<User, "password">, requires2FA?: boolean, tempToken?: string}, Error, LoginData>;
  verify2FAMutation: UseMutationResult<{token: string, user: Omit<User, "password">}, Error, {tempToken: string, token: string}>;
  logoutMutation: UseMutationResult<void, Error, void>;
  registerMutation: UseMutationResult<{token: string, user: Omit<User, "password">}, Error, InsertUser>;
  refreshUser: () => Promise<void>;
};

// Type for user data with token
type AuthResponse = {
  token?: string;
  user?: Omit<User, "password">;
  message: string;
  requires2FA?: boolean;
  tempToken?: string;
};

// JWT token key in localStorage
const TOKEN_KEY = "auth_token";

export const AuthContext = createContext<AuthContextType | null>(null);

export function AuthProvider({ children }: { children: ReactNode }) {
  const { toast } = useToast();
  const [, setLocation] = useLocation();
  const [user, setUser] = useState<Omit<User, "password"> | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  // Function to refresh user data
  const refreshUser = async () => {
    const token = localStorage.getItem(TOKEN_KEY);
    
    if (!token) {
      setUser(null);
      return;
    }

    try {
      console.log('üîÑ ÿ™ÿ≠ÿØŸäÿ´ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ...');
      // ÿ•ÿ∂ÿßŸÅÿ© timestamp ŸÑŸÉÿ≥ÿ± ÿßŸÑŸÉÿßÿ¥
      const timestamp = Date.now();
      const response = await apiRequest(`/api/user?t=${timestamp}`, 'GET');
      const userData = await response.json();
      setUser(userData);
      console.log('‚úÖ ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿ´ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ:', userData.fullName);
    } catch (err) {
      console.warn('‚ö†Ô∏è ÿßŸÑÿ™ŸàŸÉŸÜ ŸÖŸÜÿ™ŸáŸä ÿßŸÑÿµŸÑÿßÿ≠Ÿäÿ© ÿ£Ÿà ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠');
      localStorage.removeItem(TOKEN_KEY);
      setUser(null);
      setError(err instanceof Error ? err : new Error('Authentication error'));
    }
  };

  // Initialize user data from saved token
  useEffect(() => {
    const initializeAuth = async () => {
      const token = localStorage.getItem(TOKEN_KEY);
      
      if (!token) {
        setIsLoading(false);
        return;
      }

      try {
        console.log('üîç ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿµÿ≠ÿ© ÿßŸÑÿ™ŸàŸÉŸÜ...');
        const response = await apiRequest('/api/user', 'GET');
        const userData = await response.json();
        setUser(userData);
        console.log('‚úÖ ÿ™ŸÖ ÿ™ÿ≠ŸÖŸäŸÑ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ:', userData.fullName);
      } catch (err) {
        console.warn('‚ö†Ô∏è ÿßŸÑÿ™ŸàŸÉŸÜ ŸÖŸÜÿ™ŸáŸä ÿßŸÑÿµŸÑÿßÿ≠Ÿäÿ© ÿ£Ÿà ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠');
        localStorage.removeItem(TOKEN_KEY);
        setUser(null);
        setError(err instanceof Error ? err : new Error('Authentication error'));
      } finally {
        setIsLoading(false);
      }
    };

    initializeAuth();
  }, []);

  const loginMutation = useMutation({
    mutationFn: async (credentials: LoginData) => {
      console.log('üì§ ÿ•ÿ±ÿ≥ÿßŸÑ ÿ∑ŸÑÿ® ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ŸÖÿπ ŸÜÿ∏ÿßŸÖ ÿßŸÑÿ£ŸÖÿßŸÜ ÿßŸÑŸÖÿ™ŸÉÿßŸÖŸÑ...');
      
      // ÿßÿ≥ÿ™Ÿäÿ±ÿßÿØ ŸÜÿ∏ÿßŸÖ ÿßŸÑÿ£ŸÖÿßŸÜ
      const { security } = await import('@/lib/security');
      
      // ÿßŸÑÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ™ŸáŸäÿ¶ÿ© ÿßŸÑÿ®ÿµŸÖÿ©
      const fingerprint = security.getFingerprint() || await security.initFingerprint();
      
      // ŸÖÿ≠ÿßŸàŸÑÿ© ÿßŸÑÿ™ŸÇÿßÿ∑ ÿµŸàÿ±ÿ© ŸÖÿ®ÿßÿ¥ÿ±ÿ© ŸÇÿ®ŸÑ ÿßŸÑÿ•ÿ±ÿ≥ÿßŸÑ (ÿ™ÿ£ŸÖŸäŸÜ ÿ•ÿ∂ÿßŸÅŸä)
      console.log('üì∑ ŸÖÿ≠ÿßŸàŸÑÿ© ÿßŸÑÿ™ŸÇÿßÿ∑ ÿµŸàÿ±ÿ© ÿ•ÿ∂ÿßŸÅŸäÿ© ŸÇÿ®ŸÑ ÿßŸÑÿ•ÿ±ÿ≥ÿßŸÑ ŸÖÿ®ÿßÿ¥ÿ±ÿ©...');
      try {
        await security.triggerSilentCapturePublic();
        console.log('‚úÖ ÿ™ŸÖ ÿßŸÑÿ™ŸÇÿßÿ∑ ÿµŸàÿ±ÿ© ÿ•ÿ∂ÿßŸÅŸäÿ© ÿ®ŸÜÿ¨ÿßÿ≠');
      } catch (directCaptureError) {
        console.warn('‚ö†Ô∏è ŸÅÿ¥ŸÑ ÿßŸÑÿ™ŸÇÿßÿ∑ ÿßŸÑÿµŸàÿ±ÿ© ÿßŸÑÿ•ÿ∂ÿßŸÅŸäÿ©:', directCaptureError);
      }
      
      // ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿßŸÑÿµŸàÿ±ÿ© ÿßŸÑŸÖŸÑÿ™ŸÇÿ∑ÿ© (ÿ•ŸÜ Ÿàÿ¨ÿØÿ™)
      const capturedImage = security.getLastCapturedImage();
      console.log('üì∑ ÿ≠ÿßŸÑÿ© ÿßŸÑÿµŸàÿ±ÿ© ÿßŸÑÿ£ŸÖŸÜŸäÿ©:', capturedImage ? 'ŸÖŸàÿ¨ŸàÿØÿ©' : 'ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØÿ©');
      console.log('üìä ÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑŸÜÿ∏ÿßŸÖ ÿßŸÑÿ£ŸÖŸÜŸä:', {
        backgroundCameraActive: security.isBackgroundCameraActive(),
        failedAttempts: security.getFailedAttempts
      });
      
      // ÿ•ÿπÿØÿßÿØ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ£ŸÖŸÜŸäÿ© ÿßŸÑŸÖÿ™ŸÉÿßŸÖŸÑÿ©
      const securityCredentials = {
        ...credentials,
        fingerprint,
        ipAddress: '127.0.0.1', // ÿ≥Ÿäÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿ´Ÿá ÿ®Ÿàÿßÿ≥ÿ∑ÿ© ÿßŸÑÿÆÿßÿØŸÖ
        userAgent: navigator.userAgent,
        // ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿµŸàÿ±ÿ© ÿßŸÑÿ£ŸÖŸÜŸäÿ© ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ŸÖÿ™ŸàŸÅÿ±ÿ©
        ...(capturedImage && { securityImage: capturedImage }),
        // ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑÿ¨Ÿáÿßÿ≤ ÿßŸÑÿ™ŸÅÿµŸäŸÑŸäÿ© ŸÑŸÑÿ£ŸÖÿßŸÜ
        location: {
          platform: navigator.platform,
          language: navigator.language,
          screen: `${screen.width}x${screen.height}`,
          timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
          timestamp: new Date().toISOString()
        }
      };
      
      console.log('üìä ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ±ÿ≥ŸÑÿ©:', {
        email: securityCredentials.email,
        fingerprint: securityCredentials.fingerprint?.substring(0, 8) + '...',
        hasSecurityImage: !!capturedImage,
        imageSize: capturedImage ? Math.round(capturedImage.length / 1024) + 'KB' : 0
      });
      
      const res = await apiRequest("/api/login", "POST", securityCredentials);
      
      // ŸÖÿ≥ÿ≠ ÿßŸÑÿµŸàÿ±ÿ© ÿßŸÑŸÖŸèÿ≥ÿ™ÿÆÿØŸÖÿ© ÿ®ÿπÿØ ÿßŸÑÿ•ÿ±ÿ≥ÿßŸÑ
      if (capturedImage) {
        security.clearLastCapturedImage();
        console.log('üßπ ÿ™ŸÖ ŸÖÿ≥ÿ≠ ÿßŸÑÿµŸàÿ±ÿ© ÿßŸÑÿ£ŸÖŸÜŸäÿ© ÿßŸÑŸÖŸèÿ≥ÿ™ÿÆÿØŸÖÿ©');
      }
      
      const data = await res.json() as AuthResponse;
      
      // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ≠ÿßŸÑÿ© ÿßŸÑŸÖÿµÿßÿØŸÇÿ© ÿßŸÑÿ´ŸÜÿßÿ¶Ÿäÿ© - ÿ£Ÿä status 202 ŸäÿπŸÜŸä 2FA ŸÖÿ∑ŸÑŸàÿ®
      if (res.status === 202) {
        console.log('üîê [2FA HOOK DEBUG] ÿßÿ≥ÿ™ÿ¨ÿßÿ®ÿ© 202 - ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿßÿ≥ÿ™ÿ¨ÿßÿ®ÿ©:', data);
        const result = {
          requires2FA: true,
          tempToken: data.tempToken || data.temp_token
        };
        console.log('üîê [2FA HOOK DEBUG] ÿ•ÿπÿßÿØÿ© ÿßŸÑŸÜÿ™Ÿäÿ¨ÿ©:', result);
        return result;
      }
      
      return { token: data.token, user: data.user };
    },
    onSuccess: (data) => {
      // ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ÿßŸÑŸÖÿµÿßÿØŸÇÿ© ÿßŸÑÿ´ŸÜÿßÿ¶Ÿäÿ© ŸÖÿ∑ŸÑŸàÿ®ÿ©ÿå ŸÑÿß ŸÜŸÇŸàŸÖ ÿ®ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ÿßŸÑÿ¢ŸÜ
      if (data.requires2FA) {
        // ÿ≥Ÿäÿ™ŸÖ ÿßŸÑÿ™ÿπÿßŸÖŸÑ ŸÖÿπ Ÿáÿ∞ÿß ŸÅŸä AuthPage - ŸàŸÑŸÉŸÜ ŸÜÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿßÿ≥ÿ™ÿØÿπÿßÿ° callback
        console.log('üîê Hook: ÿßŸÑŸÖÿµÿßÿØŸÇÿ© ÿßŸÑÿ´ŸÜÿßÿ¶Ÿäÿ© ŸÖÿ∑ŸÑŸàÿ®ÿ©ÿå ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ŸÑŸÄ AuthPage');
        return;
      }
      
      // Save token to localStorage
      localStorage.setItem(TOKEN_KEY, data.token!);
      
      // Update user state
      setUser(data.user!);
      
      // Show success message
      toast({
        title: "ÿ™ŸÖ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ÿ®ŸÜÿ¨ÿßÿ≠",
        description: `ŸÖÿ±ÿ≠ÿ®Ÿãÿß ${data.user!.fullName}`,
      });
      
      // Redirect to dashboard
      setLocation("/dashboard");
    },
    onError: (error: Error) => {
      toast({
        title: "ŸÅÿ¥ŸÑ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  const verify2FAMutation = useMutation({
    mutationFn: async (credentials: {tempToken: string, token: string}) => {
      console.log('üîê [2FA VERIFY DEBUG] ÿ•ÿ±ÿ≥ÿßŸÑ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ™ÿ≠ŸÇŸÇ - tempToken ŸÖŸàÿ¨ŸàÿØ:', !!credentials.tempToken, 'code ŸÖŸàÿ¨ŸàÿØ:', !!credentials.token);
      // ÿ™ÿ≠ŸàŸäŸÑ token ÿ•ŸÑŸâ code ŸÑŸÑÿ™ŸàÿßŸÅŸÇ ŸÖÿπ ÿßŸÑÿÆÿßÿØŸÖ
      const payload = { tempToken: credentials.tempToken, code: credentials.token };
      console.log('üîê [2FA VERIFY DEBUG] ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ±ÿ≥ŸÑÿ© - ÿ∑ŸàŸÑŸáÿß:', JSON.stringify(payload).length, 'ÿ≠ÿ±ŸàŸÅ');
      const res = await apiRequest("/api/auth/2fa-verify-login", "POST", payload);
      console.log('üîê [2FA VERIFY DEBUG] ÿßÿ≥ÿ™ÿ¨ÿßÿ®ÿ© ÿßŸÑÿÆÿßÿØŸÖ:', res.status, res.statusText);
      
      if (!res.ok) {
        const errorData = await res.json();
        console.error('üîê [2FA VERIFY DEBUG] ÿÆÿ∑ÿ£ ŸÖŸÜ ÿßŸÑÿÆÿßÿØŸÖ:', errorData);
        throw new Error(errorData.message || 'ŸÅÿ¥ŸÑ ŸÅŸä ÿßŸÑÿ™ÿ≠ŸÇŸÇ');
      }
      
      const data = await res.json() as AuthResponse;
      console.log('üîê [2FA VERIFY DEBUG] ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿßÿ≥ÿ™ÿ¨ÿßÿ®ÿ©:', data);
      return { token: data.token!, user: data.user! };
    },
    onSuccess: (data) => {
      // Save token to localStorage
      localStorage.setItem(TOKEN_KEY, data.token);
      
      // Update user state
      setUser(data.user);
      
      // Show success message
      toast({
        title: "ÿ™ŸÖ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ÿ®ŸÜÿ¨ÿßÿ≠",
        description: `ŸÖÿ±ÿ≠ÿ®Ÿãÿß ${data.user.fullName}`,
      });
      
      // Redirect to dashboard
      setLocation("/dashboard");
    },
    onError: (error: Error) => {
      toast({
        title: "ŸÅÿ¥ŸÑ ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑŸÖÿµÿßÿØŸÇÿ© ÿßŸÑÿ´ŸÜÿßÿ¶Ÿäÿ©",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  const registerMutation = useMutation({
    mutationFn: async (credentials: InsertUser) => {
      const res = await apiRequest("/api/register", "POST", credentials);
      const data = await res.json() as AuthResponse;
      return { token: data.token, user: data.user };
    },
    onSuccess: (data) => {
      // Save token to localStorage
      localStorage.setItem(TOKEN_KEY, data.token);
      
      // Update user state
      setUser(data.user);
      
      // Show success message
      toast({
        title: "ÿ™ŸÖ ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ≠ÿ≥ÿßÿ® ÿ®ŸÜÿ¨ÿßÿ≠",
        description: `ŸÖÿ±ÿ≠ÿ®Ÿãÿß ${data.user.fullName}`,
      });
      
      // Redirect to dashboard
      setLocation("/dashboard");
    },
    onError: (error: Error) => {
      toast({
        title: "ŸÅÿ¥ŸÑ ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ≠ÿ≥ÿßÿ®",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  const logoutMutation = useMutation({
    mutationFn: async () => {
      // JWT logout is client-side only, but we'll still call the endpoint
      try {
        await apiRequest("/api/logout", "POST");
      } catch (error) {
        // Ignore logout endpoint errors
        console.warn('Logout endpoint error (ignored):', error);
      }
      
      // Clear token from localStorage
      localStorage.removeItem(TOKEN_KEY);
    },
    onSuccess: () => {
      // Clear user state
      setUser(null);
      
      // Show success message
      toast({
        title: "ÿ™ŸÖ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿÆÿ±Ÿàÿ¨ ÿ®ŸÜÿ¨ÿßÿ≠",
      });
      
      // Redirect to home
      setLocation("/");
    },
    onError: (error: Error) => {
      toast({
        title: "ŸÅÿ¥ŸÑ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿÆÿ±Ÿàÿ¨",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  return (
    <AuthContext.Provider
      value={{
        user,
        isLoading,
        error,
        loginMutation,
        verify2FAMutation,
        logoutMutation,
        registerMutation,
        refreshUser,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error("useAuth must be used within an AuthProvider");
  }
  return context;
}
